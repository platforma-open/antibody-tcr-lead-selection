// Main template for clonotype filtering
wf := import("@platforma-sdk/workflow-tengo:workflow")
exec := import("@platforma-sdk/workflow-tengo:exec")
assets := import("@platforma-sdk/workflow-tengo:assets")
xsv := import("@platforma-sdk/workflow-tengo:pframes.xsv")
pframes := import("@platforma-sdk/workflow-tengo:pframes")
slices := import("@platforma-sdk/workflow-tengo:slices")
render := import("@platforma-sdk/workflow-tengo:render")
ll := import("@platforma-sdk/workflow-tengo:ll")
kabatConv := import(":pf-kabat-conv")

spectratypeConv := import(":pf-spectratype-conv")
vjUsageConv := import(":pf-vj-usage-conv")
utils := import(":utils")

filterAndSampleTpl := assets.importTemplate(":filter-and-sample")

wf.prepare(func(args){
	if is_undefined(args.inputAnchor) {
        return {
            columns: wf.createPBundleBuilder().build()
        }
    }
	// We need a table with cluster ID (optional) | clonotype id | selected ranking columns
    bundleBuilder := wf.createPBundleBuilder()
    bundleBuilder.ignoreMissingDomains() // to make query work for both bulk and single cell data
    bundleBuilder.addAnchor("main", args.inputAnchor) 
    
    validRanks := false
    if len(args.rankingOrder) > 0 {
        for col in args.rankingOrder {
            // For cases where the user is selecting the table to filter
            if col.value != undefined {
                bundleBuilder.addAnchor(col.value.anchorName, col.value.anchorRef)
                bundleBuilder.addSingle(col.value.column)
                validRanks = true
            }
        }
    }

    // Load filter columns
    if len(args.filters) > 0 {
        for filter in args.filters {
            if filter.value != undefined {
                bundleBuilder.addAnchor(filter.value.anchorName, filter.value.anchorRef)
                bundleBuilder.addSingle(filter.value.column)
            }
        }
    }
    

    // Add linker columns
    bundleBuilder.addMulti({
        axes: [{ anchor: "main", idx: 1 }], // this will do partial axes match (unlike in the model)
        annotations: { "pl7.app/isLinkerColumn": "true" },
        partialAxesMatch: true
    }, "linkers")
    
    // Add clusterColumn as a named anchor for matching in body phase
    if !is_undefined(args.clusterColumn) {
        bundleBuilder.addAnchor("selectedCluster", args.clusterColumn)
    }

    // Add cluster size columns from clustering blocks
    bundleBuilder.addMulti({
        name: "pl7.app/vdj/clustering/clusterSize",
        partialAxesMatch: true
    }, "clusterSizes")

    // Add CDR3 sequences
	bundleBuilder.addMulti({
		axes: [{ anchor: "main", idx: 1 }], // Clonotype axis
		name: "pl7.app/vdj/sequence",
		domain: {
			"pl7.app/alphabet": "aminoacid",
			"pl7.app/vdj/feature": "CDR3"    // Specify CDR3 feature
		}
	}, "cdr3Sequences") // New collection name for CDR3 sequences

	// Add V gene
	bundleBuilder.addMulti({
		axes: [{ anchor: "main", idx: 1 }], // Clonotype axis
		name: "pl7.app/vdj/geneHit",
		domain: {
			"pl7.app/vdj/reference": "VGene"
		}
	}, "VGenes")

	// Add J gene
	bundleBuilder.addMulti({
		axes: [{ anchor: "main", idx: 1 }], // Clonotype axis
		name: "pl7.app/vdj/geneHit",
		domain: {
			"pl7.app/vdj/reference": "JGene"
		}
	}, "JGenes")

	// Add assembling feature aminoacid sequences (bulk, sc, scFv)
	bundleBuilder.addMulti({
		axes: [{ anchor: "main", idx: 1 }], // Clonotype axis
		annotations: { "pl7.app/vdj/isAssemblingFeature": "true" },
		domain: { "pl7.app/alphabet": "aminoacid" }
	}, "assemblingAaSeqs")
    
    return {
        columns: bundleBuilder.build()
    }
})

wf.body(func(args) {
	// output containers 
	outputs := {}

    if !is_undefined(args.inputAnchor) {
        // Input arguments
        columns := args.columns
        datasetSpec := columns.getSpec(args.inputAnchor)
        topClonotypes := args.topClonotypes

        // Needed conditional variable
	    isSingleCell := datasetSpec.axesSpec[1].name == "pl7.app/vdj/scClonotypeKey"
    
        ////////// Clonotype Filtering //////////
        // Build clonotype table
        cloneTable := pframes.parquetFileBuilder() 
        cloneTable.setAxisHeader(datasetSpec.axesSpec[1], "clonotypeKey")

        // Add Filters to table
        addedAxes := []
        filterMap := {}
        rankingMap := {}
        addedCols := false
        if len(args.filters) > 0 {
            for i, filter in args.filters {
                // we check for value presence and for actual pcolumn (cases where upstream block is deleted)
                if filter.value != undefined && columns.getColumn(filter.value.column).spec != undefined {
                    // Columns added here might also be in ranking list, so we add default IDs
                    cloneTable.add(columns.getColumn(filter.value.column), 
                                    {header: "Filter_" + string(i), id: "filter_" + string(i)})
                    addedCols = true
                    // Store reference value and filter type associated to this column
                    filterMap["Filter_" + string(i)] = filter.filter
                    filterMap["Filter_" + string(i)]["valueType"] = columns.getSpec(filter.value.column).valueType
                
                    // If column does not have main anchor axis we have to include theirs
                    colsSpec := columns.getSpec(filter.value.column)
                    axesNames := slices.map(colsSpec.axesSpec, func (a) { return a.name})
                    if !slices.hasElement(axesNames, datasetSpec.axesSpec[1].name) {
                        for na, ax in colsSpec.axesSpec {
                            if ax.name != datasetSpec.axesSpec[1].name {
                                cloneTable.setAxisHeader(ax, "cluster_" + string(i) + string(na))
                                addedAxes = append(addedAxes, ax.name)
                            }
                        }
                    }	
                }
            }
        }

        // Build linker list in SAME ORDER as model (index.ts util.ts):
        // 1. First: linkers where clonotypeKey is in SECOND axis
        // 2. Then: linkers where clonotypeKey is in FIRST axis
        // NO SORTING - must match the order from getOptions/getColumns to align with linker-N indices
        allLinkersUnsorted := columns.getColumns("linkers")
        
        // Collect linkers by axis position (same iteration order as model)
        sortedLinkers := []
        for col in allLinkersUnsorted {
            if datasetSpec.axesSpec[1].name == col.spec.axesSpec[1].name {
                sortedLinkers = append(sortedLinkers, col)
            }
        }
        for col in allLinkersUnsorted {
            if datasetSpec.axesSpec[1].name == col.spec.axesSpec[0].name {
                sortedLinkers = append(sortedLinkers, col)
            }
        }

        // Add ranking columns to table
        validRanks := false
        clusterPropertyIdx := 0
        clonotypePropertyIdx := 0
        linkerColumnCounters := {}  // Track column count per linker index
        
        if len(args.rankingOrder) > 0 {
            for i, col in args.rankingOrder {
                // we check for value presence and for actual pcolumn (cases where upstream block is deleted)
                if col.value != undefined && columns.getColumn(col.value.column).spec != undefined {
                    validRanks = true
                    
                    // Process the ranking column to determine header and cluster axis
                    colsSpec := columns.getSpec(col.value.column)
                    // Use sortedLinkers for consistent ordering with model
                    result := utils.processRankingColumn(colsSpec, datasetSpec.axesSpec[1].name, sortedLinkers, clusterPropertyIdx)
                    
                    header := ""
                    if result.isClusterProperty {
                        // Check if this column is from a linker
                        if result.isLinkerColumn {
                            // Track and use counter for this specific linker
                            linkerKey := "linker_" + string(result.clusterAxisIdx)
                            if is_undefined(linkerColumnCounters[linkerKey]) {
                                linkerColumnCounters[linkerKey] = 0
                            }
                            counter := linkerColumnCounters[linkerKey]
                            header = "Col_linker." + string(result.clusterAxisIdx) + "." + string(counter)
                            linkerColumnCounters[linkerKey] = counter + 1
                        } else {
                            header = result.header
                            clusterPropertyIdx = result.newClusterPropertyIdx
                        }
                        
                        // Add cluster axis with matching index
                        for na, ax in colsSpec.axesSpec {
                            if ax.name != datasetSpec.axesSpec[1].name && !slices.hasElement(addedAxes, ax.name) {
                                axisHeader := "cluster_" + string(result.clusterAxisIdx)
                                cloneTable.setAxisHeader(ax, axisHeader)
                                addedAxes = append(addedAxes, ax.name)
                            }
                        }
                    } else {
                        header = "Col" + string(clonotypePropertyIdx)
                        clonotypePropertyIdx = clonotypePropertyIdx + 1
                    }
                    
                    cloneTable.add(columns.getColumn(col.value.column), {header: header})
                    addedCols = true
                    rankingMap[header] = col.rankingOrder
                }
            }
        }

        // Get linker columns if needed
        // Use sortedLinkers which was already built above with proper ordering
        linkerAxisSpec := {}
        // Store both the axis AND the original linker index for cluster size matching
        linkerClusterIdAxesWithIdx := []
        
        for linkerIdx, col in sortedLinkers {
            clusterIdAxis := undefined
            if datasetSpec.axesSpec[1].name == col.spec.axesSpec[1].name {
                // clonotypeKey is in second axis
                cloneTable.add(col, {header: "linker." + string(linkerIdx)})
                cloneTable.setAxisHeader(col.spec.axesSpec[0], "cluster_" + string(linkerIdx))
                linkerAxisSpec["cluster_" + string(linkerIdx)] = col.spec.axesSpec[0]
                clusterIdAxis = col.spec.axesSpec[0]
                addedCols = true
            } else if datasetSpec.axesSpec[1].name == col.spec.axesSpec[0].name {
                // clonotypeKey is in first axis
                cloneTable.add(col, {header: "linker." + string(linkerIdx)})
                cloneTable.setAxisHeader(col.spec.axesSpec[1], "cluster_" + string(linkerIdx))
                linkerAxisSpec["cluster_" + string(linkerIdx)] = col.spec.axesSpec[1]
                clusterIdAxis = col.spec.axesSpec[1]
                addedCols = true
            }
            // Collect clusterId axes from linker columns to match cluster size columns
            // Store both axis and original linker index to preserve correct mapping
            if !is_undefined(clusterIdAxis) && clusterIdAxis.name == "pl7.app/vdj/clusterId" {
                linkerClusterIdAxesWithIdx = append(linkerClusterIdAxesWithIdx, {
                    axis: clusterIdAxis,
                    linkerIdx: linkerIdx
                })
            }
        }

        // Add cluster size columns if available, but only those matching linker columns' clusterId axes
        // This ensures we only join columns from the same clustering run
        if len(columns.getColumns("clusterSizes")) > 0 {
            clusterSizeIdx := 0
            for col in columns.getColumns("clusterSizes") {
                // Find the clusterId axis in this cluster size column
                clusterSizeClusterIdAxis := undefined
                for axis in col.spec.axesSpec {
                    if axis.name == "pl7.app/vdj/clusterId" {
                        clusterSizeClusterIdAxis = axis
                        break
                    }
                }
                
                // Only add if we have linker columns and this cluster size matches one of them
                // Also find the matching linker index to use for consistent naming
                matchingLinkerIdx := -1
                if len(linkerClusterIdAxesWithIdx) > 0 && !is_undefined(clusterSizeClusterIdAxis) {
                    // Check if this cluster size column matches any linker's clusterId axis
                    for entry in linkerClusterIdAxesWithIdx {
                        linkerAxis := entry.axis
                        // Compare domains - they must match exactly for same clustering run
                        if clusterSizeClusterIdAxis.name == linkerAxis.name &&
                           clusterSizeClusterIdAxis.type == linkerAxis.type &&
                           utils.clusterAxisDomainsMatch(clusterSizeClusterIdAxis, linkerAxis) {
                            // Use the original linker index, not the array index
                            matchingLinkerIdx = entry.linkerIdx
                            break
                        }
                    }
                }
                
                // Only add cluster size columns that match a linker column's clustering run
                if matchingLinkerIdx >= 0 {
                    // Trace elements are already present in col.spec from the clustering block.
                    // deriveLabels (in label.ts) will use these existing trace elements to construct
                    // distinguishing labels when multiple clustering blocks are joined, similar to
                    // how LabelTypeFull ('__LABEL__@1') works. The trace includes:
                    // - Original dataset trace
                    // - "milaboratories.clonotype-clustering.sequences" trace element
                    // - "milaboratories.clonotype-clustering.clustering" trace element
                    // No modification needed - just preserve the existing trace.
                    
                    // Use matching linker index for clusterSize header to maintain consistency
                    cloneTable.add(col, {header: "clusterSize." + string(matchingLinkerIdx)})
                    addedCols = true
                    // Add the cluster axis header using matching linker index
                    // This ensures cluster_N from linker processing matches clusterAxis_N_M from cluster size
                    for axisIdx, axis in col.spec.axesSpec {
                        if axis.name != datasetSpec.axesSpec[1].name {
                            cloneTable.setAxisHeader(axis, "clusterAxis_" + string(matchingLinkerIdx) + "_" + string(axisIdx))
                        }
                    }
                    clusterSizeIdx = clusterSizeIdx + 1
                }
            }
        }

        // Fallback: if no columns have been added yet, add at least one CDR3 sequence column
        // This ensures the table can be built even when no filters/ranking columns are specified
        if !addedCols {
            cdr3Sequences := columns.getColumns("cdr3Sequences")
            if len(cdr3Sequences) > 0 {
                // Add the first CDR3 sequence as a fallback column
                cloneTable.add(cdr3Sequences[0], {header: "cdr3_fallback"})
                addedCols = true
            }
        }

        // Continue only if we have at least a column
        // This condition prevents temporal intermittent error while filters are 
        // being processed and possibly in other situations too
        if addedCols {
            cloneTable.mem("16GiB")
            cloneTable.cpu(1)
            cloneTable = cloneTable.build()

            // Resolve clusterColumn ref to header name by matching against sortedLinkers
            clusterColumnHeader := undefined
            if !is_undefined(args.clusterColumn) {
                // Get the spec for the selected cluster column (added as anchor in prepare phase)
                selectedLinkerSpec := columns.getSpec(args.clusterColumn)
                if !is_undefined(selectedLinkerSpec) {
                    // Find the clusterId axis in the selected linker
                    selectedClusterIdAxis := undefined
                    for axis in selectedLinkerSpec.axesSpec {
                        if axis.name == "pl7.app/vdj/clusterId" {
                            selectedClusterIdAxis = axis
                            break
                        }
                    }
                    
                    if !is_undefined(selectedClusterIdAxis) {
                        // Find matching linker by comparing clusterId axis domains
                        for linkerIdx, col in sortedLinkers {
                            // Get the clusterId axis from this linker
                            for axis in col.spec.axesSpec {
                                if axis.name == "pl7.app/vdj/clusterId" {
                                    // Use clusterAxisDomainsMatch for proper domain comparison
                                    if utils.clusterAxisDomainsMatch(selectedClusterIdAxis, axis) {
                                        clusterColumnHeader = "clusterAxis_" + string(linkerIdx) + "_0"
                                        break
                                    }
                                }
                            }
                            if !is_undefined(clusterColumnHeader) {
                                break
                            }
                        }
                    }
                }
            }

            // Use ender.create to call the filter-clonotypes template
            filterSampleResult := render.create(filterAndSampleTpl, {
                inputAnchor: args.inputAnchor,
                cloneTable: cloneTable,
                rankingOrder: args.rankingOrder,
                filters: args.filters,
                filterMap: filterMap,
                rankingMap: rankingMap,
                datasetSpec: datasetSpec,
                topClonotypes: args.topClonotypes,
                disableClusterRanking: args.disableClusterRanking,
                clusterColumn: clusterColumnHeader
            })
            
            // Get the filtered clonotypes from the template result
            outputs["sampledRows"] = filterSampleResult.output("sampledRows", 24 * 60 * 60 * 1000)

            // Get the filtered and sampled clonotypes P-frame from the template result
            finalClonotypes := filterSampleResult.output("finalClonotypes", 24 * 60 * 60 * 1000)
            
            ////////// CDR3 Length Calculation //////////
                
            cdr3SeqTable := pframes.parquetFileBuilder()
            cdr3SeqTable.setAxisHeader(datasetSpec.axesSpec[1].name, "clonotypeKey")

            // Must deal with multiple CDR3 sequences (two for each cell in single cell data)
            // Chain will be added in the header as cdr3Sequence.chain and used in python script
            // Notice chain is in spec.domain for single cell data and spec.axesSpec[0].domain for bulk data

            // Helper function to add chain information to the headers dynamically
            chainMapping := {
                "IG": { "A": "Heavy", "B": "Light" },
                "TCRAB": { "A": "TRA", "B": "TRB" },
                "TCRGD": { "A": "TRG", "B": "TRD" }
            }

            makeHeaderName := func(col, baseHeaderName, isSingleCell) {
                if isSingleCell {
                    chain := col.spec.domain["pl7.app/vdj/scClonotypeChain"]  // e.g., "A", "B"
                    receptor := col.spec.axesSpec[0].domain["pl7.app/vdj/receptor"]  // e.g., "IG", "TCRAB", "TCRGD"
                    chainLabel := chainMapping[receptor][chain]
                    return baseHeaderName + "." + chainLabel // e.g., "cdr3Sequence.Heavy"
                } else {
                    // For bulk, if chain info is available (e.g. IGH, IGK, IGL)
                    chainFromDomain := col.spec.axesSpec[0].domain["pl7.app/vdj/chain"] // e.g. "IGH", "IGK"
                    if chainFromDomain != undefined {
                        return baseHeaderName + "." + chainFromDomain // e.g., "cdr3Sequence.IGH"
                    }
                }
                return baseHeaderName
            };

            // Process CDR3 sequences
            cdr3Sequences := columns.getColumns("cdr3Sequences")

            for col in cdr3Sequences {
                headerName := makeHeaderName(col, "cdr3Sequence", isSingleCell)
                if isSingleCell {
                    if col.spec.domain["pl7.app/vdj/scClonotypeChain/index"] == "primary" {
                        cdr3SeqTable.add(col, {header: headerName})
                    }
                } else {
                    cdr3SeqTable.add(col, {header: headerName})
                }
            }

            // Process V genes
            vGenes := columns.getColumns("VGenes")	

            for col in vGenes {
                headerName := makeHeaderName(col, "vGene", isSingleCell)
                cdr3SeqTable.add(col, {header: headerName})
            }

            // Process J genes
            jGenes := columns.getColumns("JGenes")	

            for col in jGenes {
                headerName := makeHeaderName(col, "jGene", isSingleCell)
                cdr3SeqTable.add(col, {header: headerName})
            }

            cdr3SeqTable.mem("16GiB")
            cdr3SeqTable.cpu(1)
            cdr3SeqTableBuilt := cdr3SeqTable.build()

            cdr3VspectratypeCmd := exec.builder().
                software(assets.importSoftware("@platforma-open/milaboratories.top-antibodies.spectratype:main")).
                mem("16GiB").
                cpu(1).
                addFile("cdr3_sequences_input.parquet", cdr3SeqTableBuilt).
                arg("--input_parquet").arg("cdr3_sequences_input.parquet").
                arg("--spectratype_tsv").arg("spectratype.tsv").
                arg("--vj_usage_tsv").arg("vj_usage.tsv") // no dot here

            // Add top clonotypes argument and file to the builder if provided
            if finalClonotypes != undefined {
                cdr3VspectratypeCmd = cdr3VspectratypeCmd.
                    arg("--final-clonotypes").arg("finalClonotypes.parquet").
                    addFile("finalClonotypes.parquet", finalClonotypes)
            }

            cdr3VspectratypeCmd = cdr3VspectratypeCmd. // continue building the command
                saveFile("spectratype.tsv").
                saveFile("vj_usage.tsv").
                printErrStreamToStdout().
                cache(24 * 60 * 60 * 1000).
                run()


            // Spectratype PFrame structure is [chain][cdr3Length][vGene] -> count

            cdr3VspectratypePf := xsv.importFile(cdr3VspectratypeCmd.getFile("spectratype.tsv"), 
                                                "tsv", spectratypeConv.getColumns(),
                                                {cpu: 1, mem: "16GiB"})
            outputs["cdr3VspectratypePf"] = pframes.exportFrame(cdr3VspectratypePf) 

            // For vjUsage structure is [chain][vGene][jGene] -> count
            vjUsagePf := xsv.importFile(cdr3VspectratypeCmd.getFile("vj_usage.tsv"), 
                                        "tsv", vjUsageConv.getColumns(), 
                                        {cpu: 1, mem: "16GiB"})
            outputs["vjUsagePf"] = pframes.exportFrame(vjUsagePf)

            if args.kabatNumbering == true {
            ////////// Assembling AA sequences //////////
                assemSeqTable := pframes.parquetFileBuilder()
                keyHeader := "clonotypeKey"
                assemSeqTable.setAxisHeader(datasetSpec.axesSpec[1].name, keyHeader)

                seqCols := columns.getColumns("assemblingAaSeqs")
                for col in seqCols {
                    headerName := makeHeaderName(col, "assemblingFeature", isSingleCell)
                    assemSeqTable.add(col, {header: headerName})
                }

                assemSeqTable.mem("16GiB")
                assemSeqTable.cpu(1)
                assemSeqTableBuilt := assemSeqTable.build()

                // Convert assembling feature sequences to FASTA via sub-template
                assemFastaTpl := assets.importTemplate(":assembling-fasta")
                bulkChain := undefined
                if !isSingleCell {
                    // infer bulk chain by header names of incoming seq columns (domain uses IGHeavy / IGLight)
                    chainDetected := "KL"
                    for col in seqCols {
                        ch := col.spec.axesSpec[0].domain["pl7.app/vdj/chain"] // e.g., IGHeavy, IGLight
                        if ch == "IGHeavy" { chainDetected = "H"; break }
                        if ch == "IGLight" { chainDetected = "KL" }
                    }
                    bulkChain = chainDetected
                }
                assem := render.create(assemFastaTpl, {
                    inputTsv: assemSeqTableBuilt,
                    keyColumn: "clonotypeKey",
                    finalClonotypes: finalClonotypes,
                    isSingleCell: isSingleCell,
                    bulkChain: bulkChain
                })
                //outputs["assemblingAnarci"] = assem.output("anarci", 24 * 60 * 60 * 1000)
                kabatFile := assem.output("kabat", 24 * 60 * 60 * 1000)
                // Derive feature name from assembling feature columns (prefer first column's feature)
                featName := ""
                if len(seqCols) > 0 {
                    f := seqCols[0].spec.domain["pl7.app/vdj/feature"]
                    if f != undefined { featName = f }
                }
                // Convert kabat.tsv to PFrame with proper specs (bulk: select heavy/light)
                kabatPf := xsv.importFile(kabatFile, "tsv", kabatConv.getColumns(datasetSpec, featName, bulkChain), {cpu: 1, mem: "8GiB"})
                outputs["assemblingKabatPf"] = pframes.exportFrame(kabatPf)
            }
        }
    }

	return {
		outputs: outputs,
		exports: {}
	}
})
